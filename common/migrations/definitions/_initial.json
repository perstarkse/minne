{"schemas":"# Defines the schema for the 'analytics' table.\n\nDEFINE TABLE IF NOT EXISTS analytics SCHEMALESS;\n\n# Custom fields from the Analytics struct\nDEFINE FIELD IF NOT EXISTS page_loads ON analytics TYPE number;\nDEFINE FIELD IF NOT EXISTS visitors ON analytics TYPE number;\n\n# Defines authentication scope and access rules.\n# This mirrors the logic previously in SurrealDbClient::setup_auth\n\nDEFINE ACCESS IF NOT EXISTS account ON DATABASE TYPE RECORD\n    SIGNUP ( CREATE user SET email = $email, password = crypto::argon2::generate($password), anonymous = false, user_id = $user_id) # Ensure user_id is provided if needed\n    SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(password, $password) );\n\n# Defines the schema for the 'conversation' table.\n\nDEFINE TABLE IF NOT EXISTS conversation SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON conversation TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON conversation TYPE datetime;\n\n# Custom fields from the Conversation struct\nDEFINE FIELD IF NOT EXISTS user_id ON conversation TYPE string;\nDEFINE FIELD IF NOT EXISTS title ON conversation TYPE string;\n\n# Add indexes based on query patterns (get_complete_conversation ownership check, get_user_conversations)\nDEFINE INDEX IF NOT EXISTS conversation_user_id_idx ON conversation FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS conversation_created_at_idx ON conversation FIELDS created_at; # For get_user_conversations ORDER BY\n\n# Defines the schema for the 'file' table (used by FileInfo).\n\nDEFINE TABLE IF NOT EXISTS file SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON file TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON file TYPE datetime;\n\n# Custom fields from the FileInfo struct\nDEFINE FIELD IF NOT EXISTS sha256 ON file TYPE string;\nDEFINE FIELD IF NOT EXISTS path ON file TYPE string;\nDEFINE FIELD IF NOT EXISTS file_name ON file TYPE string;\nDEFINE FIELD IF NOT EXISTS mime_type ON file TYPE string;\nDEFINE FIELD IF NOT EXISTS user_id ON file TYPE string;\n\n# Indexes based on usage (get_by_sha, potentially user lookups)\n# Using UNIQUE based on the logic in FileInfo::new to prevent duplicates\nDEFINE INDEX IF NOT EXISTS file_sha256_idx ON file FIELDS sha256 UNIQUE;\nDEFINE INDEX IF NOT EXISTS file_user_id_idx ON file FIELDS user_id;\n\n# Defines the schema for the 'ingestion_task' table (used by IngestionTask).\n\nDEFINE TABLE IF NOT EXISTS ingestion_task SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON ingestion_task TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON ingestion_task TYPE datetime;\n\nDEFINE FIELD IF NOT EXISTS content ON ingestion_task TYPE object;\nDEFINE FIELD IF NOT EXISTS status ON ingestion_task TYPE object;\nDEFINE FIELD IF NOT EXISTS user_id ON ingestion_task TYPE string;\n\n# Indexes explicitly defined in build_indexes and useful for get_unfinished_tasks\nDEFINE INDEX IF NOT EXISTS idx_ingestion_task_status ON ingestion_task FIELDS status;\nDEFINE INDEX IF NOT EXISTS idx_ingestion_task_user ON ingestion_task FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS idx_ingestion_task_created ON ingestion_task FIELDS created_at;\n\n# Defines the schema for the 'knowledge_entity' table.\n\nDEFINE TABLE IF NOT EXISTS knowledge_entity SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON knowledge_entity TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON knowledge_entity TYPE datetime;\n\n# Custom fields from the KnowledgeEntity struct\nDEFINE FIELD IF NOT EXISTS source_id ON knowledge_entity TYPE string;\nDEFINE FIELD IF NOT EXISTS name ON knowledge_entity TYPE string;\nDEFINE FIELD IF NOT EXISTS description ON knowledge_entity TYPE string;\n# KnowledgeEntityType is an enum, store as string\nDEFINE FIELD IF NOT EXISTS entity_type ON knowledge_entity TYPE string;\n# metadata is Option<serde_json::Value>, store as object\nDEFINE FIELD IF NOT EXISTS metadata ON knowledge_entity TYPE option<object>;\n\nDEFINE FIELD IF NOT EXISTS user_id ON knowledge_entity TYPE string;\n\n# Indexes based on build_indexes and query patterns\n# The INDEX definition correctly specifies the vector properties\n# HNSW index now defined on knowledge_entity_embedding table for better memory usage  \n# DEFINE INDEX IF NOT EXISTS idx_embedding_entities ON knowledge_entity FIELDS embedding HNSW DIMENSION 1536;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_source_id_idx ON knowledge_entity FIELDS source_id;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_user_id_idx ON knowledge_entity FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_entity_type_idx ON knowledge_entity FIELDS entity_type;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_created_at_idx ON knowledge_entity FIELDS created_at;\n\n# Defines the schema for the 'knowledge_entity_embedding' table.\n# Separate table to optimize HNSW index creation memory usage\n\nDEFINE TABLE IF NOT EXISTS knowledge_entity_embedding SCHEMAFULL;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON knowledge_entity_embedding TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON knowledge_entity_embedding TYPE datetime;\nDEFINE FIELD IF NOT EXISTS user_id ON knowledge_entity_embedding TYPE string;\n\n# Custom fields\nDEFINE FIELD IF NOT EXISTS entity_id ON knowledge_entity_embedding TYPE record<knowledge_entity>;\nDEFINE FIELD IF NOT EXISTS embedding ON knowledge_entity_embedding TYPE array<float>;\n\n# Indexes\n# DEFINE INDEX IF NOT EXISTS idx_embedding_knowledge_entity_embedding ON knowledge_entity_embedding FIELDS embedding HNSW DIMENSION 1536;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_embedding_entity_id_idx ON knowledge_entity_embedding FIELDS entity_id;\nDEFINE INDEX IF NOT EXISTS knowledge_entity_embedding_user_id_idx ON knowledge_entity_embedding FIELDS user_id;\n\n# Defines the schema for the 'message' table.\n\nDEFINE TABLE IF NOT EXISTS message SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON message TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON message TYPE datetime;\n\n# Custom fields from the Message struct\nDEFINE FIELD IF NOT EXISTS conversation_id ON message TYPE string;\n# MessageRole is an enum, store as string\nDEFINE FIELD IF NOT EXISTS role ON message TYPE string;\nDEFINE FIELD IF NOT EXISTS content ON message TYPE string;\n# references is Option<Vec<String>>, store as array<string>\nDEFINE FIELD IF NOT EXISTS references ON message TYPE option<array<string>>;\n\n# Indexes based on query patterns (get_complete_conversation)\nDEFINE INDEX IF NOT EXISTS message_conversation_id_idx ON message FIELDS conversation_id;\nDEFINE INDEX IF NOT EXISTS message_updated_at_idx ON message FIELDS updated_at; # For ORDER BY\n\n# Defines the 'relates_to' edge table for KnowledgeRelationships.\n# Edges connect nodes, in this case knowledge_entity records.\n\n# Define the edge table itself, enforcing connections between knowledge_entity records\n# SCHEMAFULL requires all fields to be defined, maybe start with SCHEMALESS if metadata might vary\nDEFINE TABLE IF NOT EXISTS relates_to SCHEMALESS TYPE RELATION FROM knowledge_entity TO knowledge_entity;\n\n# Define the metadata field within the edge\n# RelationshipMetadata is a struct, store as object\nDEFINE FIELD IF NOT EXISTS metadata ON relates_to TYPE object;\n\n# Optionally, define fields within the metadata object for stricter schema (requires SCHEMAFULL on table)\n# DEFINE FIELD IF NOT EXISTS metadata.user_id ON relates_to TYPE string;\n# DEFINE FIELD IF NOT EXISTS metadata.source_id ON relates_to TYPE string;\n# DEFINE FIELD IF NOT EXISTS metadata.relationship_type ON relates_to TYPE string;\n\n# Add indexes based on query patterns (delete_relationships_by_source_id, get_knowledge_relationships)\nDEFINE INDEX IF NOT EXISTS relates_to_metadata_source_id_idx ON relates_to FIELDS metadata.source_id;\nDEFINE INDEX IF NOT EXISTS relates_to_metadata_user_id_idx ON relates_to FIELDS metadata.user_id;\n\n# Defines the schema for the 'scratchpad' table.\n\nDEFINE TABLE IF NOT EXISTS scratchpad SCHEMALESS;\n\n# Standard fields from stored_object! macro\nDEFINE FIELD IF NOT EXISTS created_at ON scratchpad TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON scratchpad TYPE datetime;\n\n# Custom fields from the Scratchpad struct\nDEFINE FIELD IF NOT EXISTS user_id ON scratchpad TYPE string;\nDEFINE FIELD IF NOT EXISTS title ON scratchpad TYPE string;\nDEFINE FIELD IF NOT EXISTS content ON scratchpad TYPE string;\nDEFINE FIELD IF NOT EXISTS last_saved_at ON scratchpad TYPE datetime;\nDEFINE FIELD IF NOT EXISTS is_dirty ON scratchpad TYPE bool DEFAULT false;\nDEFINE FIELD IF NOT EXISTS is_archived ON scratchpad TYPE bool DEFAULT false;\nDEFINE FIELD IF NOT EXISTS archived_at ON scratchpad TYPE option<datetime>;\nDEFINE FIELD IF NOT EXISTS ingested_at ON scratchpad TYPE option<datetime>;\n\n# Indexes based on query patterns\nDEFINE INDEX IF NOT EXISTS scratchpad_user_idx ON scratchpad FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS scratchpad_user_archived_idx ON scratchpad FIELDS user_id, is_archived;\nDEFINE INDEX IF NOT EXISTS scratchpad_updated_idx ON scratchpad FIELDS updated_at;\nDEFINE INDEX IF NOT EXISTS scratchpad_archived_idx ON scratchpad FIELDS archived_at;\n\nDEFINE TABLE OVERWRITE script_migration SCHEMAFULL\n    PERMISSIONS\n        FOR select FULL\n        FOR create, update, delete NONE;\n\nDEFINE FIELD OVERWRITE script_name ON script_migration TYPE string;\nDEFINE FIELD OVERWRITE executed_at ON script_migration TYPE datetime VALUE time::now() READONLY;\n\n# Defines the schema for the 'system_settings' table.\n\nDEFINE TABLE IF NOT EXISTS system_settings SCHEMALESS;\n\n# Custom fields from the SystemSettings struct\nDEFINE FIELD IF NOT EXISTS registrations_enabled ON system_settings TYPE bool;\nDEFINE FIELD IF NOT EXISTS require_email_verification ON system_settings TYPE bool;\nDEFINE FIELD IF NOT EXISTS query_model ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS processing_model ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS image_processing_model ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS embedding_model ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS embedding_dimensions ON system_settings TYPE int;\nDEFINE FIELD IF NOT EXISTS query_system_prompt ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS ingestion_system_prompt ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS image_processing_prompt ON system_settings TYPE string;\nDEFINE FIELD IF NOT EXISTS voice_processing_model ON system_settings TYPE string;\n\n# Defines the schema for the 'text_chunk' table.\n\nDEFINE TABLE IF NOT EXISTS text_chunk SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON text_chunk TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON text_chunk TYPE datetime;\n\n# Custom fields from the TextChunk struct\nDEFINE FIELD IF NOT EXISTS source_id ON text_chunk TYPE string;\nDEFINE FIELD IF NOT EXISTS chunk ON text_chunk TYPE string;\n\nDEFINE FIELD IF NOT EXISTS user_id ON text_chunk TYPE string;\n\n# Indexes based on build_indexes and query patterns (delete_by_source_id)\nDEFINE INDEX IF NOT EXISTS text_chunk_source_id_idx ON text_chunk FIELDS source_id;\nDEFINE INDEX IF NOT EXISTS text_chunk_user_id_idx ON text_chunk FIELDS user_id;\n\n# Defines the schema for the 'text_chunk_embedding' table.\n# Separate table to optimize HNSW index creation memory usage\n\nDEFINE TABLE IF NOT EXISTS text_chunk_embedding SCHEMAFULL;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON text_chunk_embedding TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON text_chunk_embedding TYPE datetime;\nDEFINE FIELD IF NOT EXISTS user_id ON text_chunk_embedding TYPE string;\nDEFINE FIELD IF NOT EXISTS source_id ON text_chunk_embedding TYPE string;\n\n# Custom fields\nDEFINE FIELD IF NOT EXISTS chunk_id ON text_chunk_embedding TYPE record<text_chunk>;\nDEFINE FIELD IF NOT EXISTS embedding ON text_chunk_embedding TYPE array<float>;\n\n# Indexes\n# DEFINE INDEX IF NOT EXISTS idx_embedding_text_chunk_embedding ON text_chunk_embedding FIELDS embedding HNSW DIMENSION 1536;\nDEFINE INDEX IF NOT EXISTS text_chunk_embedding_chunk_id_idx ON text_chunk_embedding FIELDS chunk_id;\nDEFINE INDEX IF NOT EXISTS text_chunk_embedding_user_id_idx ON text_chunk_embedding FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS text_chunk_embedding_source_id_idx ON text_chunk_embedding FIELDS source_id;\n\n# Defines the schema for the 'text_content' table.\n\nDEFINE TABLE IF NOT EXISTS text_content SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON text_content TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON text_content TYPE datetime;\n\n# Custom fields from the TextContent struct\nDEFINE FIELD IF NOT EXISTS text ON text_content TYPE string;\n# FileInfo is a struct, store as object\nDEFINE FIELD IF NOT EXISTS file_info ON text_content TYPE option<object>;\n# UrlInfo is a struct, store as object\nDEFINE FIELD IF NOT EXISTS url_info ON text_content TYPE option<object>;\nDEFINE FIELD IF NOT EXISTS context ON text_content TYPE option<string>;\nDEFINE FIELD IF NOT EXISTS category ON text_content TYPE string;\nDEFINE FIELD IF NOT EXISTS user_id ON text_content TYPE string;\n\n# Indexes based on query patterns\nDEFINE INDEX IF NOT EXISTS text_content_user_id_idx ON text_content FIELDS user_id;\nDEFINE INDEX IF NOT EXISTS text_content_created_at_idx ON text_content FIELDS created_at;\nDEFINE INDEX IF NOT EXISTS text_content_category_idx ON text_content FIELDS category;\n\n# Defines the schema for the 'user' table.\n# NOTE: Authentication scope and access rules are defined in auth.surql\n\nDEFINE TABLE IF NOT EXISTS user SCHEMALESS;\n\n# Standard fields\nDEFINE FIELD IF NOT EXISTS created_at ON user TYPE datetime;\nDEFINE FIELD IF NOT EXISTS updated_at ON user TYPE datetime;\n\n# Custom fields from the User struct\nDEFINE FIELD IF NOT EXISTS email ON user TYPE string;\nDEFINE FIELD IF NOT EXISTS password ON user TYPE string; # Stores the hashed password\nDEFINE FIELD IF NOT EXISTS anonymous ON user TYPE bool;\nDEFINE FIELD IF NOT EXISTS api_key ON user TYPE option<string>;\nDEFINE FIELD IF NOT EXISTS admin ON user TYPE bool;\nDEFINE FIELD IF NOT EXISTS timezone ON user TYPE string;\n\n# Indexes based on query patterns (find_by_email, find_by_api_key, unique constraint from setup_auth)\nDEFINE INDEX IF NOT EXISTS user_email_idx ON user FIELDS email UNIQUE;\nDEFINE INDEX IF NOT EXISTS user_api_key_idx ON user FIELDS api_key;\n","events":""}